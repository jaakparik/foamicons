import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import { toPascalCase, getIconVariant, type IconVariant } from '@foamicons/core';

interface IconData {
  id: string;
  name: string;
  variants: {
    stroke?: string;
    duotone?: string;
    fill?: string;
  };
  tags: string[];
}

async function main() {
  const iconsDir = join(process.cwd(), '../../icons');
  const files = await readdir(iconsDir);
  const svgFiles = files.filter(f => f.endsWith('.svg')).sort();

  console.log(`Found ${svgFiles.length} SVG files`);

  // Group by base icon name
  const iconsMap = new Map<string, IconData>();

  for (const file of svgFiles) {
    const variant = getIconVariant(file);
    const baseName = file
      .replace('-duotone.svg', '')
      .replace('-fill.svg', '')
      .replace('.svg', '');

    const id = baseName;
    const name = toPascalCase(baseName);
    const svgContent = await readFile(join(iconsDir, file), 'utf-8');

    // Clean up SVG for Figma plugin
    // - Remove XML declaration and extra whitespace
    // - Strip stroke-width (will be applied dynamically at runtime)
    const cleanSvg = svgContent
      .replace(/<\?xml[^>]*\?>/g, '')
      .replace(/\s*stroke-width="[^"]*"/g, '')
      .replace(/\n/g, ' ')
      .replace(/\s+/g, ' ')
      .trim();

    if (!iconsMap.has(id)) {
      iconsMap.set(id, {
        id,
        name,
        variants: {},
        tags: baseName.split('-').filter(t => t.length > 1)
      });
    }

    const iconData = iconsMap.get(id)!;
    iconData.variants[variant as keyof typeof iconData.variants] = cleanSvg;
  }

  const icons = Array.from(iconsMap.values()).sort((a, b) => a.id.localeCompare(b.id));

  // Validate - check each icon has all 3 variants
  let missingVariants = 0;
  for (const icon of icons) {
    const missing: string[] = [];
    if (!icon.variants.stroke) missing.push('stroke');
    if (!icon.variants.duotone) missing.push('duotone');
    if (!icon.variants.fill) missing.push('fill');
    if (missing.length > 0) {
      console.warn(`  Warning: ${icon.id} missing variants: ${missing.join(', ')}`);
      missingVariants++;
    }
  }

  // Generate TypeScript file
  const output = `// Auto-generated by generate-icons.ts - do not edit manually
// Generated: ${new Date().toISOString()}

export interface IconData {
  id: string;
  name: string;
  variants: {
    stroke?: string;
    duotone?: string;
    fill?: string;
  };
  tags: string[];
}

export const iconsData: IconData[] = ${JSON.stringify(icons, null, 2)};

export const iconCount = ${icons.length};
`;

  await writeFile(join(process.cwd(), 'src/icons-data.ts'), output);

  console.log(`\n✓ Generated ${icons.length} icons to src/icons-data.ts`);
  if (missingVariants > 0) {
    console.log(`⚠ ${missingVariants} icons have missing variants`);
  }
}

main().catch(console.error);
